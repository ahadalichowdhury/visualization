package export

import (
	"fmt"
	"strings"
)

// CloudFormationGenerator generates AWS CloudFormation YAML templates
type CloudFormationGenerator struct {
	nodes []NodeInput
	edges []EdgeInput
}

// NewCloudFormationGenerator creates a new CloudFormation generator
func NewCloudFormationGenerator(nodes []NodeInput, edges []EdgeInput) *CloudFormationGenerator {
	return &CloudFormationGenerator{
		nodes: nodes,
		edges: edges,
	}
}

// Generate generates the complete CloudFormation template
func (g *CloudFormationGenerator) Generate() string {
	var output strings.Builder

	// Header
	output.WriteString("# Generated by Architecture Visualization Platform\n")
	output.WriteString("AWSTemplateFormatVersion: '2010-09-09'\n")
	output.WriteString("Description: 'Infrastructure stack generated from architecture diagram'\n\n")

	// Parameters
	output.WriteString(g.generateParameters())
	output.WriteString("\n")

	// Resources
	output.WriteString("Resources:\n")
	for _, node := range g.nodes {
		resource := g.nodeToCloudFormationResource(node)
		if resource != "" {
			output.WriteString(resource)
		}
	}

	// Outputs
	output.WriteString("\n")
	output.WriteString(g.generateOutputs())

	return output.String()
}

// generateParameters generates parameter definitions
func (g *CloudFormationGenerator) generateParameters() string {
	return `Parameters:
  Environment:
    Type: String
    Default: dev
    Description: Environment name (dev, staging, prod)
    AllowedValues:
      - dev
      - staging
      - prod

  ProjectName:
    Type: String
    Default: arch-viz
    Description: Project name for resource naming
`
}

// nodeToCloudFormationResource converts a node to CloudFormation resource
func (g *CloudFormationGenerator) nodeToCloudFormationResource(node NodeInput) string {
	config := node.Data["config"].(map[string]interface{})
	label := node.Data["label"].(string)
	resourceName := sanitizeNameCF(label)

	switch node.Type {
	case "api_server", "web_server", "microservice", "worker":
		return g.generateEC2InstanceCF(resourceName, config)

	case "database_sql":
		return g.generateRDSInstanceCF(resourceName, config)

	case "database_nosql":
		return g.generateDynamoDBCF(resourceName, config)

	case "cache_redis":
		return g.generateElastiCacheCF(resourceName, config)

	case "load_balancer":
		return g.generateALBCF(resourceName, config)

	case "queue":
		return g.generateSQSCF(resourceName, config)

	case "object_storage":
		return g.generateS3BucketCF(resourceName, config)

	case "lambda_function":
		return g.generateLambdaCF(resourceName, config)

	case "api_gateway":
		return g.generateAPIGatewayCF(resourceName, config)

	case "vpc", "subnet":
		return g.generateVPCCF(resourceName, config)

	default:
		return fmt.Sprintf("  # Unsupported node type: %s (%s)\n", node.Type, label)
	}
}

// Generate EC2 Instance (CloudFormation)
func (g *CloudFormationGenerator) generateEC2InstanceCF(name string, config map[string]interface{}) string {
	instanceType := getStringOrDefault(config, "instanceType", "t3.micro")

	return fmt.Sprintf(`  %s:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: %s
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-%s'
        - Key: Environment
          Value: !Ref Environment
        - Key: ManagedBy
          Value: CloudFormation

`, name, instanceType, name)
}

// Generate RDS Instance (CloudFormation)
func (g *CloudFormationGenerator) generateRDSInstanceCF(name string, config map[string]interface{}) string {
	engine := getStringOrDefault(config, "databaseEngine", "postgres")
	instanceType := getStringOrDefault(config, "instanceType", "db.t3.micro")
	storageGB := getIntOrDefault(config, "storage_size_gb", 20)

	return fmt.Sprintf(`  %s:
    Type: AWS::RDS::DBInstance
    Properties:
      DBInstanceIdentifier: !Sub '${ProjectName}-%s'
      Engine: %s
      EngineVersion: '15.3'
      DBInstanceClass: %s
      AllocatedStorage: %d
      StorageType: gp3
      MasterUsername: admin
      MasterUserPassword: !Ref DBPassword
      PubliclyAccessible: false
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-%s'
        - Key: Environment
          Value: !Ref Environment

`, name, name, engine, instanceType, storageGB, name)
}

// Generate DynamoDB Table (CloudFormation)
func (g *CloudFormationGenerator) generateDynamoDBCF(name string, config map[string]interface{}) string {
	return fmt.Sprintf(`  %s:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ProjectName}-%s'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-%s'
        - Key: Environment
          Value: !Ref Environment

`, name, name, name)
}

// Generate ElastiCache (CloudFormation)
func (g *CloudFormationGenerator) generateElastiCacheCF(name string, config map[string]interface{}) string {
	nodeType := getStringOrDefault(config, "instanceType", "cache.t3.micro")

	return fmt.Sprintf(`  %s:
    Type: AWS::ElastiCache::CacheCluster
    Properties:
      ClusterName: !Sub '${ProjectName}-%s'
      Engine: redis
      CacheNodeType: %s
      NumCacheNodes: 1
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-%s'
        - Key: Environment
          Value: !Ref Environment

`, name, name, nodeType, name)
}

// Generate Application Load Balancer (CloudFormation)
func (g *CloudFormationGenerator) generateALBCF(name string, config map[string]interface{}) string {
	return fmt.Sprintf(`  %s:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${ProjectName}-%s'
      Type: application
      Scheme: internet-facing
      IpAddressType: ipv4
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-%s'
        - Key: Environment
          Value: !Ref Environment

`, name, name, name)
}

// Generate SQS Queue (CloudFormation)
func (g *CloudFormationGenerator) generateSQSCF(name string, config map[string]interface{}) string {
	return fmt.Sprintf(`  %s:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${ProjectName}-%s'
      DelaySeconds: 0
      MaximumMessageSize: 262144
      MessageRetentionPeriod: 345600
      ReceiveMessageWaitTimeSeconds: 0
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-%s'
        - Key: Environment
          Value: !Ref Environment

`, name, name, name)
}

// Generate S3 Bucket (CloudFormation)
func (g *CloudFormationGenerator) generateS3BucketCF(name string, config map[string]interface{}) string {
	return fmt.Sprintf(`  %s:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ProjectName}-%s-${Environment}'
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-%s'
        - Key: Environment
          Value: !Ref Environment

`, name, name, name)
}

// Generate Lambda Function (CloudFormation)
func (g *CloudFormationGenerator) generateLambdaCF(name string, config map[string]interface{}) string {
	runtime := getStringOrDefault(config, "runtime", "nodejs18.x")
	memoryMB := getIntOrDefault(config, "memoryMB", 128)

	return fmt.Sprintf(`  %s:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-%s'
      Runtime: %s
      MemorySize: %d
      Timeout: 30
      Handler: index.handler
      Role: !GetAtt %sRole.Arn
      Code:
        ZipFile: |
          exports.handler = async (event) => {
            return { statusCode: 200, body: 'Hello World' };
          };
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-%s'
        - Key: Environment
          Value: !Ref Environment

  %sRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

`, name, name, runtime, memoryMB, name, name, name)
}

// Generate API Gateway (CloudFormation)
func (g *CloudFormationGenerator) generateAPIGatewayCF(name string, config map[string]interface{}) string {
	return fmt.Sprintf(`  %s:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub '${ProjectName}-%s'
      Description: API Gateway managed by CloudFormation
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-%s'
        - Key: Environment
          Value: !Ref Environment

`, name, name, name)
}

// Generate VPC (CloudFormation)
func (g *CloudFormationGenerator) generateVPCCF(name string, config map[string]interface{}) string {
	return fmt.Sprintf(`  %s:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-%s'
        - Key: Environment
          Value: !Ref Environment

`, name, name)
}

// generateOutputs generates output values
func (g *CloudFormationGenerator) generateOutputs() string {
	var output strings.Builder

	output.WriteString("Outputs:\n")
	for _, node := range g.nodes {
		resourceName := sanitizeNameCF(node.Data["label"].(string))
		switch node.Type {
		case "load_balancer":
			output.WriteString(fmt.Sprintf(`  %sDNS:
    Description: DNS name of the load balancer
    Value: !GetAtt %s.DNSName
    Export:
      Name: !Sub '${AWS::StackName}-%s-dns'
`, resourceName, resourceName, resourceName))
		case "api_gateway":
			output.WriteString(fmt.Sprintf(`  %sURL:
    Description: URL of the API Gateway
    Value: !Sub 'https://${%s}.execute-api.${AWS::Region}.amazonaws.com'
    Export:
      Name: !Sub '${AWS::StackName}-%s-url'
`, resourceName, resourceName, resourceName))
		}
	}

	return output.String()
}

// Helper function to sanitize resource names for CloudFormation
func sanitizeNameCF(name string) string {
	// CloudFormation resource names must be alphanumeric (no underscores or hyphens in logical IDs)
	name = strings.ReplaceAll(name, " ", "")
	name = strings.ReplaceAll(name, "-", "")
	name = strings.ReplaceAll(name, "_", "")
	// Capitalize first letter
	if len(name) > 0 {
		name = strings.ToUpper(name[:1]) + name[1:]
	}
	return name
}
